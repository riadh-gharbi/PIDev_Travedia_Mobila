package group.diamonddev;


/**
 *  A sequence of {@code long}-valued elements supporting aggregate operations.
 * 
 *  @author Diamond
 *  @see Stream
 *  @since 1.0.0
 */
public final class LongStream implements function.Closeable {

	/**
	 *  Returns an empty stream.
	 * 
	 *  @return the empty stream
	 */
	public static LongStream empty() {
	}

	/**
	 *  Creates a {@code LongStream} from {@code PrimitiveIterator.OfLong}.
	 * 
	 *  @param iterator the iterator with elements to be passed to stream
	 * 
	 *  @return the new {@code LongStream}
	 *  @throws NullPointerException if {@code iterator} is null
	 */
	public static LongStream of(iterator.PrimitiveIterator.OfLong iterator) {
	}

	/**
	 *  Creates a {@code LongStream} from the specified values.
	 * 
	 *  @param values the elements of the new stream
	 * 
	 *  @return the new stream
	 *  @throws NullPointerException if {@code values} is null
	 */
	public static LongStream of(long[] values) {
	}

	/**
	 *  Returns stream which contains single element passed as param
	 * 
	 *  @param t element of the stream
	 * 
	 *  @return the new stream
	 */
	public static LongStream of(long t) {
	}

	/**
	 *  Returns a sequential ordered {@code LongStream} from {@code startInclusive}
	 *  (inclusive) to {@code endExclusive} (exclusive) by an incremental step of
	 *  {@code 1}.
	 * 
	 *  @param startInclusive the (inclusive) initial value
	 *  @param endExclusive   the exclusive upper bound
	 * 
	 *  @return a sequential {@code LongStream} for the range of {@code long}
	 *  elements
	 */
	public static LongStream range(long startInclusive, long endExclusive) {
	}

	/**
	 *  Returns a sequential ordered {@code LongStream} from {@code startInclusive}
	 *  (inclusive) to {@code endInclusive} (inclusive) by an incremental step of
	 *  {@code 1}.
	 * 
	 *  @param startInclusive the (inclusive) initial value
	 *  @param endInclusive   the inclusive upper bound
	 * 
	 *  @return a sequential {@code LongStream} for the range of {@code long}
	 *  elements
	 */
	public static LongStream rangeClosed(long startInclusive, long endInclusive) {
	}

	/**
	 *  Creates a {@code LongStream} by elements that generated by {@code LongSupplier}.
	 * 
	 *  @param s the {@code LongSupplier} for generated elements
	 * 
	 *  @return a new infinite sequential {@code LongStream}
	 *  @throws NullPointerException if {@code s} is null
	 */
	public static LongStream generate(function.LongSupplier s) {
	}

	/**
	 *  Creates a {@code LongStream} by iterative application {@code LongUnaryOperator} function
	 *  to an initial element {@code seed}. Produces {@code LongStream} consisting of
	 *  {@code seed}, {@code f(seed)}, {@code f(f(seed))}, etc.
	 * 
	 *  <p> The first element (position {@code 0}) in the {@code LongStream} will be
	 *  the provided {@code seed}. For {@code n > 0}, the element at position
	 *  {@code n}, will be the result of applying the function {@code f} to the
	 *  element at position {@code n - 1}.
	 * 
	 *  <p>Example:
	 *  <pre>
	 *  seed: 1
	 *  f: (a) -&gt; a + 5
	 *  result: [1, 6, 11, 16, ...]
	 *  </pre>
	 * 
	 *  @param seed the initial element
	 *  @param f    a function to be applied to the previous element to produce a new element
	 * 
	 *  @return a new sequential {@code LongStream}
	 *  @throws NullPointerException if {@code f} is null
	 */
	public static LongStream iterate(long seed, function.LongUnaryOperator f) {
	}

	/**
	 *  Creates an {@code LongStream} by iterative application {@code LongUnaryOperator} function
	 *  to an initial element {@code seed}, conditioned on satisfying the supplied predicate.
	 * 
	 *  <p>Example:
	 *  <pre>
	 *  seed: 0
	 *  predicate: (a) -&gt; a &lt; 20
	 *  f: (a) -&gt; a + 5
	 *  result: [0, 5, 10, 15]
	 *  </pre>
	 * 
	 *  @param seed      the initial value
	 *  @param predicate a predicate to determine when the stream must terminate
	 *  @param op        operator to produce new element by previous one
	 * 
	 *  @return the new stream
	 *  @throws NullPointerException if {@code op} is null
	 *  @since 1.0.0
	 */
	public static LongStream iterate(long seed, function.LongPredicate predicate, function.LongUnaryOperator op) {
	}

	/**
	 *  Lazily concatenates two streams.
	 * 
	 *  <p>Example:
	 *  <pre>
	 *  stream a: [1, 2, 3, 4]
	 *  stream b: [5, 6]
	 *  result:   [1, 2, 3, 4, 5, 6]
	 *  </pre>
	 * 
	 *  @param a the first stream
	 *  @param b the second stream
	 * 
	 *  @return the new concatenated stream
	 *  @throws NullPointerException if {@code a} or {@code b} is null
	 */
	public static LongStream concat(LongStream a, LongStream b) {
	}

	/**
	 *  Lazily concatenates three or more streams.
	 * 
	 *  <p>Example:
	 *  <pre>
	 *  stream a: [1, 2, 3, 4]
	 *  stream b: [5, 6]
	 *  stream c: [7]
	 *  stream d: [8, 9, 10]
	 *  result:   [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
	 *  </pre>
	 * 
	 *  @param a    the first stream
	 *  @param b    the second stream
	 *  @param rest the rest of streams
	 * 
	 *  @return the new concatenated stream
	 *  @throws NullPointerException if {@code a} or {@code b}
	 *                               or {@code rest} is null
	 *  @since 1.0.0
	 */
	public static LongStream concat(LongStream a, LongStream b, LongStream[] rest) {
	}

	/**
	 *  Returns internal {@code LongStream} iterator.
	 * 
	 *  @return internal {@code LongStream} iterator.
	 */
	public iterator.PrimitiveIterator.OfLong iterator() {
	}

	/**
	 *  Applies a custom operator on a stream.
	 *  <p>
	 *  Transforming function can return {@code LongStream} for intermediate operations,
	 *  or any value for terminal operation.
	 * 
	 *  <p>Operator examples:
	 *  <pre><code>
	 *      // Intermediate operator
	 *      public class Zip implements Function&lt;LongStream, LongStream&gt; {
	 * 
	 *          private final LongStream secondStream;
	 *          private final LongBinaryOperator combiner;
	 * 
	 *          public Zip(LongStream secondStream, LongBinaryOperator combiner) {
	 *              this.secondStream = secondStream;
	 *              this.combiner = combiner;
	 *          }
	 * 
	 *          &#64;Override
	 *          public LongStream apply(LongStream firstStream) {
	 *              final PrimitiveIterator.OfLong it1 = firstStream.iterator();
	 *              final PrimitiveIterator.OfLong it2 = secondStream.iterator();
	 *              return LongStream.of(new PrimitiveIterator.OfLong() {
	 *                  &#64;Override
	 *                  public boolean hasNext() {
	 *                      return it1.hasNext() &amp;&amp; it2.hasNext();
	 *                  }
	 * 
	 *                  &#64;Override
	 *                  public long nextLong() {
	 *                      return combiner.applyAsLong(it1.nextLong(), it2.nextLong());
	 *                  }
	 *              });
	 *          }
	 *      }
	 * 
	 *      // Intermediate operator based on existing stream operators
	 *      public class SkipAndLimit implements UnaryOperator&lt;LongStream&gt; {
	 * 
	 *          private final int skip, limit;
	 * 
	 *          public SkipAndLimit(int skip, int limit) {
	 *              this.skip = skip;
	 *              this.limit = limit;
	 *          }
	 * 
	 *          &#64;Override
	 *          public LongStream apply(LongStream stream) {
	 *              return stream.skip(skip).limit(limit);
	 *          }
	 *      }
	 * 
	 *      // Terminal operator
	 *      public class LongSummaryStatistics implements Function&lt;LongStream, long[]&gt; {
	 *          &#64;Override
	 *          public long[] apply(LongStream stream) {
	 *              long count = 0;
	 *              long sum = 0;
	 *              final PrimitiveIterator.OfLong it = stream.iterator();
	 *              while (it.hasNext()) {
	 *                  count++;
	 *                  sum += it.nextLong();
	 *              }
	 *              return new long[] {count, sum};
	 *          }
	 *      }
	 *  </code></pre>
	 * 
	 *  @param <R>      the type of the result
	 *  @param function a transforming function
	 * 
	 *  @return a result of the transforming function
	 *  @throws NullPointerException if {@code function} is null
	 *  @see Stream#custom(Function)
	 */
	public Object custom(function.Function function) {
	}

	/**
	 *  Returns a {@code Stream} consisting of the elements of this stream,
	 *  each boxed to an {@code Long}.
	 * 
	 *  <p>This is a lazy intermediate operation.
	 * 
	 *  @return a {@code Stream} consistent of the elements of this stream,
	 *  each boxed to an {@code Long}
	 */
	public Stream boxed() {
	}

	/**
	 *  Prepends given {@code LongStream} to current and returns a new stream.
	 *  <p>
	 *  This is similar to {@code LongStream.concat(stream, this)}
	 * 
	 *  <p>Example:
	 *  <pre>
	 *  current: [1, 2, 3]
	 *  stream:  [4, 5, 6]
	 *  result:  [4, 5, 6, 1, 2, 3]
	 *  </pre>
	 * 
	 *  @param stream the stream to prepend
	 * 
	 *  @return the new stream
	 *  @see #concat(LongStream, LongStream)
	 *  @since 1.0.0
	 */
	public LongStream prepend(LongStream stream) {
	}

	/**
	 *  Appends given {@code LongStream} to current and returns a new stream.
	 *  <p>
	 *  This is similar to {@code LongStream.concat(this, stream)}
	 * 
	 *  <p>Example:
	 *  <pre>
	 *  current: [1, 2, 3]
	 *  stream:  [4, 5, 6]
	 *  result:  [1, 2, 3, 4, 5, 6]
	 *  </pre>
	 * 
	 *  @param stream the stream to append
	 * 
	 *  @return the new stream
	 *  @see #concat(LongStream, LongStream)
	 *  @since 1.0.0
	 */
	public LongStream append(LongStream stream) {
	}

	/**
	 *  Returns {@code LongStream} with elements that satisfy the given predicate.
	 * 
	 *  <p> This is an intermediate operation.
	 * 
	 *  <p>Example:
	 *  <pre>
	 *  predicate: (a) -&gt; a &gt; 2
	 *  stream: [1, 2, 3, 4, -8, 0, 11]
	 *  result: [3, 4, 11]
	 *  </pre>
	 * 
	 *  @param predicate the predicate used to filter elements
	 * 
	 *  @return the new stream
	 */
	public LongStream filter(function.LongPredicate predicate) {
	}

	/**
	 *  Returns a {@code LongStream} with elements that satisfy the given {@code IndexedLongPredicate}.
	 * 
	 *  <p>This is an intermediate operation.
	 * 
	 *  <p>Example:
	 *  <pre>
	 *  predicate: (index, value) -&gt; (index + value) &gt; 6
	 *  stream: [1, 2, 3, 4, 0, 11]
	 *  index:  [0, 1, 2, 3, 4,  5]
	 *  sum:    [1, 3, 5, 7, 4, 16]
	 *  filter: [         7,    16]
	 *  result: [4, 11]
	 *  </pre>
	 * 
	 *  @param predicate the {@code IndexedLongPredicate} used to filter elements
	 * 
	 *  @return the new stream
	 *  @since 1.0.0
	 */
	public LongStream filterIndexed(function.IndexedLongPredicate predicate) {
	}

	/**
	 *  Returns a {@code LongStream} with elements that satisfy the given {@code IndexedLongPredicate}.
	 * 
	 *  <p>This is an intermediate operation.
	 * 
	 *  <p>Example:
	 *  <pre>
	 *  from: 4
	 *  step: 3
	 *  predicate: (index, value) -&gt; (index + value) &gt; 15
	 *  stream: [1, 2,  3,  4,  0, 11]
	 *  index:  [4, 7, 10, 13, 16, 19]
	 *  sum:    [5, 9, 13, 17, 16, 30]
	 *  filter: [          17, 16, 30]
	 *  result: [4, 0, 11]
	 *  </pre>
	 * 
	 *  @param from      the initial value of the index (inclusive)
	 *  @param step      the step of the index
	 *  @param predicate the {@code IndexedLongPredicate} used to filter elements
	 * 
	 *  @return the new stream
	 *  @since 1.0.0
	 */
	public LongStream filterIndexed(int from, int step, function.IndexedLongPredicate predicate) {
	}

	/**
	 *  Returns {@code LongStream} with elements that does not satisfy the given predicate.
	 * 
	 *  <p> This is an intermediate operation.
	 * 
	 *  @param predicate the predicate used to filter elements
	 * 
	 *  @return the new stream
	 */
	public LongStream filterNot(function.LongPredicate predicate) {
	}

	/**
	 *  Returns an {@code LongStream} consisting of the results of applying the given
	 *  function to the elements of this stream.
	 * 
	 *  <p> This is an intermediate operation.
	 * 
	 *  <p>Example:
	 *  <pre>
	 *  mapper: (a) -&gt; a + 5
	 *  stream: [1, 2, 3, 4]
	 *  result: [6, 7, 8, 9]
	 *  </pre>
	 * 
	 *  @param mapper the mapper function used to apply to each element
	 * 
	 *  @return the new stream
	 *  @see Stream#map(Function)
	 */
	public LongStream map(function.LongUnaryOperator mapper) {
	}

	/**
	 *  Returns a {@code LongStream} with elements that obtained
	 *  by applying the given {@code IndexedLongUnaryOperator}.
	 * 
	 *  <p>This is an intermediate operation.
	 * 
	 *  <p>Example:
	 *  <pre>
	 *  mapper: (index, value) -&gt; (index * value)
	 *  stream: [1, 2, 3,  4]
	 *  index:  [0, 1, 2,  3]
	 *  result: [0, 2, 6, 12]
	 *  </pre>
	 * 
	 *  @param mapper the mapper function used to apply to each element
	 * 
	 *  @return the new stream
	 *  @since 1.0.0
	 */
	public LongStream mapIndexed(function.IndexedLongUnaryOperator mapper) {
	}

	/**
	 *  Returns a {@code LongStream} with elements that obtained
	 *  by applying the given {@code IndexedLongUnaryOperator}.
	 * 
	 *  <p>This is an intermediate operation.
	 * 
	 *  <p>Example:
	 *  <pre>
	 *  from: -2
	 *  step: 2
	 *  mapper: (index, value) -&gt; (index * value)
	 *  stream: [ 1, 2, 3,  4]
	 *  index:  [-2, 0, 2,  4]
	 *  result: [-2, 0, 6, 16]
	 *  </pre>
	 * 
	 *  @param from   the initial value of the index (inclusive)
	 *  @param step   the step of the index
	 *  @param mapper the mapper function used to apply to each element
	 * 
	 *  @return the new stream
	 *  @since 1.0.0
	 */
	public LongStream mapIndexed(int from, int step, function.IndexedLongUnaryOperator mapper) {
	}

	/**
	 *  Returns a {@code Stream} consisting of the results of applying the given
	 *  function to the elements of this stream.
	 * 
	 *  <p> This is an intermediate operation.
	 * 
	 *  @param <R>    the type result
	 *  @param mapper the mapper function used to apply to each element
	 * 
	 *  @return the new {@code Stream}
	 */
	public Stream mapToObj(function.LongFunction mapper) {
	}

	/**
	 *  Returns an {@code IntStream} consisting of the results of applying the given
	 *  function to the elements of this stream.
	 * 
	 *  <p> This is an intermediate operation.
	 * 
	 *  @param mapper the mapper function used to apply to each element
	 * 
	 *  @return the new {@code IntStream}
	 */
	public IntStream mapToInt(function.LongToIntFunction mapper) {
	}

	/**
	 *  Returns an {@code DoubleStream} consisting of the results of applying the given
	 *  function to the elements of this stream.
	 * 
	 *  <p> This is an intermediate operation.
	 * 
	 *  @param mapper the mapper function used to apply to each element
	 * 
	 *  @return the new {@code DoubleStream}
	 */
	public DoubleStream mapToDouble(function.LongToDoubleFunction mapper) {
	}

	/**
	 *  Returns a stream consisting of the results of replacing each element of
	 *  this stream with the contents of a mapped stream produced by applying
	 *  the provided mapping function to each element.
	 * 
	 *  <p>This is an intermediate operation.
	 * 
	 *  <p>Example:
	 *  <pre>
	 *  mapper: (a) -&gt; [a, a + 5]
	 *  stream: [1, 2, 3, 4]
	 *  result: [1, 6, 2, 7, 3, 8, 4, 9]
	 *  </pre>
	 * 
	 *  @param mapper the mapper function used to apply to each element
	 * 
	 *  @return the new stream
	 *  @see Stream#flatMap(Function)
	 */
	public LongStream flatMap(function.LongFunction mapper) {
	}

	/**
	 *  Returns a stream consisting of the results of replacing each element of
	 *  this stream with the contents of a mapped stream produced by applying
	 *  the provided mapping function to each element.
	 * 
	 *  <p>This is an intermediate operation.
	 * 
	 *  @param mapper the mapper function used to apply to each element for producing replacing elements
	 * 
	 *  @return the new stream
	 *  @see Stream#mapMulti(group.diamonddev.function.BiConsumer)
	 *  @see LongStream#flatMap(group.diamonddev.function.LongFunction)
	 *  @since 1.0.1
	 */
	public LongStream mapMulti(LongStream.LongMapMultiConsumer mapper) {
	}

	/**
	 *  Returns a stream consisting of the distinct elements of this stream.
	 * 
	 *  <p>This is a stateful intermediate operation.
	 * 
	 *  <p>Example:
	 *  <pre>
	 *  stream: [1, 4, 2, 3, 3, 4, 1]
	 *  result: [1, 4, 2, 3]
	 *  </pre>
	 * 
	 *  @return the new stream
	 */
	public LongStream distinct() {
	}

	/**
	 *  Returns a stream consisting of the elements of this stream in sorted order.
	 * 
	 *  <p>This is a stateful intermediate operation.
	 * 
	 *  <p>Example:
	 *  <pre>
	 *  stream: [3, 4, 1, 2]
	 *  result: [1, 2, 3, 4]
	 *  </pre>
	 * 
	 *  @return the new stream
	 */
	public LongStream sorted() {
	}

	/**
	 *  Returns a stream consisting of the elements of this stream
	 *  in sorted order as determined by provided {@code Comparator}.
	 * 
	 *  <p>This is a stateful intermediate operation.
	 * 
	 *  <p>Example:
	 *  <pre>
	 *  comparator: (a, b) -&gt; -a.compareTo(b)
	 *  stream: [1, 2, 3, 4]
	 *  result: [4, 3, 2, 1]
	 *  </pre>
	 * 
	 *  @param comparator the {@code Comparator} to compare elements
	 * 
	 *  @return the new {@code LongStream}
	 */
	public LongStream sorted(java.util.Comparator comparator) {
	}

	/**
	 *  Samples the {@code LongStream} by emitting every n-th element.
	 * 
	 *  <p>This is an intermediate operation.
	 * 
	 *  <p>Example:
	 *  <pre>
	 *  stepWidth: 3
	 *  stream: [1, 2, 3, 4, 5, 6, 7, 8]
	 *  result: [1, 4, 7]
	 *  </pre>
	 * 
	 *  @param stepWidth step width
	 * 
	 *  @return the new {@code LongStream}
	 *  @throws IllegalArgumentException if {@code stepWidth} is zero or negative
	 *  @see Stream#sample(int)
	 */
	public LongStream sample(int stepWidth) {
	}

	/**
	 *  Performs provided action on each element.
	 * 
	 *  <p>This is an intermediate operation.
	 * 
	 *  @param action the action to be performed on each element
	 * 
	 *  @return the new stream
	 */
	public LongStream peek(function.LongConsumer action) {
	}

	/**
	 *  Returns a {@code LongStream} produced by iterative application of an accumulation function
	 *  to reduction value and next element of the current stream.
	 *  Produces a {@code LongStream} consisting of {@code value1}, {@code acc(value1, value2)},
	 *  {@code acc(acc(value1, value2), value3)}, etc.
	 * 
	 *  <p>This is an intermediate operation.
	 * 
	 *  <p>Example:
	 *  <pre>
	 *  accumulator: (a, b) -&gt; a + b
	 *  stream: [1, 2, 3, 4, 5]
	 *  result: [1, 3, 6, 10, 15]
	 *  </pre>
	 * 
	 *  @param accumulator the accumulation function
	 * 
	 *  @return the new stream
	 *  @throws NullPointerException if {@code accumulator} is null
	 *  @since 1.0.0
	 */
	public LongStream scan(function.LongBinaryOperator accumulator) {
	}

	/**
	 *  Returns a {@code LongStream} produced by iterative application of an accumulation function
	 *  to an initial element {@code identity} and next element of the current stream.
	 *  Produces a {@code LongStream} consisting of {@code identity}, {@code acc(identity, value1)},
	 *  {@code acc(acc(identity, value1), value2)}, etc.
	 * 
	 *  <p>This is an intermediate operation.
	 * 
	 *  <p>Example:
	 *  <pre>
	 *  identity: 0
	 *  accumulator: (a, b) -&gt; a + b
	 *  stream: [1, 2, 3, 4, 5]
	 *  result: [0, 1, 3, 6, 10, 15]
	 *  </pre>
	 * 
	 *  @param identity    the initial value
	 *  @param accumulator the accumulation function
	 * 
	 *  @return the new stream
	 *  @throws NullPointerException if {@code accumulator} is null
	 *  @since 1.0.0
	 */
	public LongStream scan(long identity, function.LongBinaryOperator accumulator) {
	}

	/**
	 *  Takes elements while the predicate returns {@code true}.
	 * 
	 *  <p>This is an intermediate operation.
	 * 
	 *  <p>Example:
	 *  <pre>
	 *  predicate: (a) -&gt; a &lt; 3
	 *  stream: [1, 2, 3, 4, 1, 2, 3, 4]
	 *  result: [1, 2]
	 *  </pre>
	 * 
	 *  @param predicate the predicate used to take elements
	 * 
	 *  @return the new {@code LongStream}
	 */
	public LongStream takeWhile(function.LongPredicate predicate) {
	}

	/**
	 *  Takes elements while the predicate returns {@code false}.
	 *  Once predicate condition is satisfied by an element, the stream
	 *  finishes with this element.
	 * 
	 *  <p>This is an intermediate operation.
	 * 
	 *  <p>Example:
	 *  <pre>
	 *  stopPredicate: (a) -&gt; a &gt; 2
	 *  stream: [1, 2, 3, 4, 1, 2, 3, 4]
	 *  result: [1, 2, 3]
	 *  </pre>
	 * 
	 *  @param stopPredicate the predicate used to take elements
	 * 
	 *  @return the new {@code LongStream}
	 *  @since 1.0.0
	 */
	public LongStream takeUntil(function.LongPredicate stopPredicate) {
	}

	/**
	 *  Drops elements while the predicate is true and returns the rest.
	 * 
	 *  <p>This is an intermediate operation.
	 * 
	 *  <p>Example:
	 *  <pre>
	 *  predicate: (a) -&gt; a &lt; 3
	 *  stream: [1, 2, 3, 4, 1, 2, 3, 4]
	 *  result: [3, 4, 1, 2, 3, 4]
	 *  </pre>
	 * 
	 *  @param predicate the predicate used to drop elements
	 * 
	 *  @return the new {@code LongStream}
	 */
	public LongStream dropWhile(function.LongPredicate predicate) {
	}

	/**
	 *  Returns a stream consisting of the elements of this stream, truncated
	 *  to be no longer than {@code maxSize} in length.
	 * 
	 *  <p> This is a short-circuiting stateful intermediate operation.
	 * 
	 *  <p>Example:
	 *  <pre>
	 *  maxSize: 3
	 *  stream: [1, 2, 3, 4, 5]
	 *  result: [1, 2, 3]
	 * 
	 *  maxSize: 10
	 *  stream: [1, 2]
	 *  result: [1, 2]
	 *  </pre>
	 * 
	 *  @param maxSize the number of elements the stream should be limited to
	 * 
	 *  @return the new stream
	 *  @throws IllegalArgumentException if {@code maxSize} is negative
	 */
	public LongStream limit(long maxSize) {
	}

	/**
	 *  Skips first {@code n} elements and returns {@code LongStream} with remaining elements.
	 *  If this stream contains fewer than {@code n} elements, then an
	 *  empty stream will be returned.
	 * 
	 *  <p>This is a stateful intermediate operation.
	 * 
	 *  <p>Example:
	 *  <pre>
	 *  n: 3
	 *  stream: [1, 2, 3, 4, 5]
	 *  result: [4, 5]
	 * 
	 *  n: 10
	 *  stream: [1, 2]
	 *  result: []
	 *  </pre>
	 * 
	 *  @param n the number of elements to skip
	 * 
	 *  @return the new stream
	 *  @throws IllegalArgumentException if {@code n} is negative
	 */
	public LongStream skip(long n) {
	}

	/**
	 *  Performs an action for each element of this stream.
	 * 
	 *  <p>This is a terminal operation.
	 * 
	 *  @param action the action to be performed on each element
	 */
	public void forEach(function.LongConsumer action) {
	}

	/**
	 *  Performs the given indexed action on each element.
	 * 
	 *  <p>This is a terminal operation.
	 * 
	 *  @param action the action to be performed on each element
	 * 
	 *  @since 1.0.0
	 */
	public void forEachIndexed(function.IndexedLongConsumer action) {
	}

	/**
	 *  Performs the given indexed action on each element.
	 * 
	 *  <p>This is a terminal operation.
	 * 
	 *  @param from   the initial value of the index (inclusive)
	 *  @param step   the step of the index
	 *  @param action the action to be performed on each element
	 * 
	 *  @since 1.0.0
	 */
	public void forEachIndexed(int from, int step, function.IndexedLongConsumer action) {
	}

	/**
	 *  Performs a reduction on the elements of this stream, using the provided
	 *  identity value, and an associative accumulation function, and returns the
	 *  reduced value.
	 * 
	 *  <p>The {@code identity} value must be an identity for the accumulator
	 *  function. This means that for all {@code x},
	 *  {@code accumulator.apply(identity, x)} is equal to {@code x}.
	 *  The {@code accumulator} function must be an associative function.
	 * 
	 *  <p>This is a terminal operation.
	 * 
	 *  <p>Example:
	 *  <pre>
	 *  identity: 0
	 *  accumulator: (a, b) -&gt; a + b
	 *  stream: [1, 2, 3, 4, 5]
	 *  result: 15
	 *  </pre>
	 * 
	 *  @param identity    the identity value for the accumulating function
	 *  @param accumulator the accumulation function
	 * 
	 *  @return the result of the reduction
	 *  @see #sum()
	 *  @see #min()
	 *  @see #max()
	 */
	public long reduce(long identity, function.LongBinaryOperator accumulator) {
	}

	/**
	 *  Performs a reduction on the elements of this stream, using an
	 *  associative accumulation function, and returns an {@code OptionalLong}
	 *  describing the reduced value, if any.
	 * 
	 *  <p>The {@code accumulator} function must be an associative function.
	 * 
	 *  <p>This is a terminal operation.
	 * 
	 *  @param accumulator the accumulation function
	 * 
	 *  @return the result of the reduction
	 *  @see #reduce(LongBinaryOperator)
	 */
	public OptionalLong reduce(function.LongBinaryOperator accumulator) {
	}

	/**
	 *  Returns an array containing the elements of this stream.
	 * 
	 *  <p>This is a terminal operation.
	 * 
	 *  @return an array containing the elements of this stream
	 */
	public long[] toArray() {
	}

	/**
	 *  Collects elements to {@code supplier} provided container by applying the given accumulation function.
	 * 
	 *  <p>This is a terminal operation.
	 * 
	 *  @param <R>         the type of the result
	 *  @param supplier    the supplier function that provides container
	 *  @param accumulator the accumulation function
	 * 
	 *  @return the result of collect elements
	 *  @see Stream#collect(Supplier, BiConsumer)
	 */
	public Object collect(function.Supplier supplier, function.ObjLongConsumer accumulator) {
	}

	/**
	 *  Returns the sum of elements in this stream.
	 * 
	 *  @return the sum of elements in this stream
	 */
	public long sum() {
	}

	/**
	 *  Returns an {@code OptionalLong} describing the minimum element of this
	 *  stream, or an empty optional if this stream is empty.
	 * 
	 *  <p>This is a terminal operation.
	 * 
	 *  @return the minimum element
	 */
	public OptionalLong min() {
	}

	/**
	 *  Returns an {@code OptionalLong} describing the maximum element of this
	 *  stream, or an empty optional if this stream is empty.
	 * 
	 *  <p>This is a terminal operation.
	 * 
	 *  @return the maximum element
	 */
	public OptionalLong max() {
	}

	/**
	 *  Returns the count of elements in this stream.
	 * 
	 *  <p>This is a terminal operation.
	 * 
	 *  @return the count of elements in this stream
	 */
	public long count() {
	}

	/**
	 *  Tests whether all elements match the given predicate.
	 *  May not evaluate the predicate on all elements if not necessary
	 *  for determining the result. If the stream is empty then
	 *  {@code false} is returned, and the predicate is not evaluated.
	 * 
	 *  <p>This is a short-circuiting terminal operation.
	 * 
	 *  <p>Example:
	 *  <pre>
	 *  predicate: (a) -&gt; a == 5
	 *  stream: [1, 2, 3, 4, 5]
	 *  result: true
	 * 
	 *  predicate: (a) -&gt; a == 5
	 *  stream: [5, 5, 5]
	 *  result: true
	 *  </pre>
	 * 
	 *  @param predicate the predicate used to match elements
	 * 
	 *  @return {@code true} if any elements of the stream match the provided
	 *  predicate, otherwise {@code false}
	 */
	public boolean anyMatch(function.LongPredicate predicate) {
	}

	/**
	 *  Tests whether all elements match the given predicate.
	 *  May not evaluate the predicate on all elements if not necessary for
	 *  determining the result. If the stream is empty then {@code true} is
	 *  returned, and the predicate is not evaluated.
	 * 
	 *  <p>This is a short-circuiting terminal operation.
	 * 
	 *  <p>Example:
	 *  <pre>
	 *  predicate: (a) -&gt; a == 5
	 *  stream: [1, 2, 3, 4, 5]
	 *  result: false
	 * 
	 *  predicate: (a) -&gt; a == 5
	 *  stream: [5, 5, 5]
	 *  result: true
	 *  </pre>
	 * 
	 *  @param predicate the predicate used to match elements
	 * 
	 *  @return {@code true} if either all elements of the stream match the
	 *  provided predicate, or the stream is empty, otherwise {@code false}
	 */
	public boolean allMatch(function.LongPredicate predicate) {
	}

	/**
	 *  Tests whether no elements match the given predicate.
	 *  May not evaluate the predicate on all elements if not necessary for
	 *  determining the result. If the stream is empty then {@code true} is
	 *  returned, and the predicate is not evaluated.
	 * 
	 *  <p>This is a short-circuiting terminal operation.
	 * 
	 *  <p>Example:
	 *  <pre>
	 *  predicate: (a) -&gt; a == 5
	 *  stream: [1, 2, 3, 4, 5]
	 *  result: false
	 * 
	 *  predicate: (a) -&gt; a == 5
	 *  stream: [1, 2, 3]
	 *  result: true
	 *  </pre>
	 * 
	 *  @param predicate the predicate used to match elements
	 * 
	 *  @return {@code true} if either no elements of the stream match the
	 *  provided predicate, or the stream is empty, otherwise {@code false}
	 */
	public boolean noneMatch(function.LongPredicate predicate) {
	}

	/**
	 *  Returns the first element wrapped by {@code OptionalLong} class.
	 *  If stream is empty, returns {@code OptionalLong.empty()}.
	 * 
	 *  <p>This is a short-circuiting terminal operation.
	 * 
	 *  @return an {@code OptionalLong} with first element
	 *  or {@code OptionalLong.empty()} if stream is empty
	 */
	public OptionalLong findFirst() {
	}

	/**
	 *  Returns the first element if stream is not empty,
	 *  otherwise returns {@code other}.
	 * 
	 *  <p>This is a short-circuiting terminal operation.
	 * 
	 *  @param other the other element to return if stream is empty
	 * 
	 *  @return first element or {@code other} if stream is empty
	 *  @since 1.0.0
	 */
	public long findFirstOrElse(long other) {
	}

	/**
	 *  Returns the last element wrapped by {@code OptionalLong} class.
	 *  If stream is empty, returns {@code OptionalLong.empty()}.
	 * 
	 *  <p>This is a short-circuiting terminal operation.
	 * 
	 *  @return an {@code OptionalLong} with the last element
	 *  or {@code OptionalLong.empty()} if the stream is empty
	 *  @since 1.0.0
	 */
	public OptionalLong findLast() {
	}

	/**
	 *  Returns the single element of stream.
	 *  If stream is empty, throws {@code NoSuchElementException}.
	 *  If stream contains more than one element, throws {@code IllegalStateException}.
	 * 
	 *  <p>This is a short-circuiting terminal operation.
	 * 
	 *  <p>Example:
	 *  <pre>
	 *  stream: []
	 *  result: NoSuchElementException
	 * 
	 *  stream: [1]
	 *  result: 1
	 * 
	 *  stream: [1, 2, 3]
	 *  result: IllegalStateException
	 *  </pre>
	 * 
	 *  @return single element of stream
	 *  @throws NoSuchElementException if stream is empty
	 *  @throws IllegalStateException  if stream contains more than one element
	 */
	public long single() {
	}

	/**
	 *  Returns the single element wrapped by {@code OptionalLong} class.
	 *  If stream is empty, returns {@code OptionalLong.empty()}.
	 *  If stream contains more than one element, throws {@code IllegalStateException}.
	 * 
	 *  <p>This is a short-circuiting terminal operation.
	 * 
	 *  <p>Example:
	 *  <pre>
	 *  stream: []
	 *  result: OptionalLong.empty()
	 * 
	 *  stream: [1]
	 *  result: OptionalLong.of(1)
	 * 
	 *  stream: [1, 2, 3]
	 *  result: IllegalStateException
	 *  </pre>
	 * 
	 *  @return an {@code OptionalLong} with single element
	 *  or {@code OptionalLong.empty()} if stream is empty
	 *  @throws IllegalStateException if stream contains more than one element
	 */
	public OptionalLong findSingle() {
	}

	/**
	 *  Adds close handler to the current stream.
	 * 
	 *  <p>This is an intermediate operation.
	 * 
	 *  @param closeHandler an action to execute when the stream is closed
	 * 
	 *  @return the new stream with the close handler
	 *  @since 1.0.0
	 */
	public LongStream onClose(Runnable closeHandler) {
	}

	/**
	 *  Causes close handler to be invoked if it exists.
	 *  Since most of the stream providers are lists or arrays,
	 *  it is not necessary to close the stream.
	 * 
	 *  @since 1.0.0
	 */
	@java.lang.Override
	public void close() {
	}

	/**
	 *  Represents an operation on two input arguments.
	 * 
	 *  @see #mapMulti(group.diamonddev.LongStream.LongMapMultiConsumer)
	 *  @since 1.0.1
	 */
	public static interface class LongMapMultiConsumer {


		/**
		 *  Replaces the given {@code value} with zero or more values
		 *  by feeding the mapped values to the {@code consumer} consumer.
		 * 
		 *  @param value    the long value coming from upstream
		 *  @param consumer a {@code LongConsumer} accepting the mapped values
		 */
		public void accept(long value, function.LongConsumer consumer) {
		}
	}
}
